<?php
// $Id$

/**
 * Implementation of hook_views_api().
 */
function om_timeslot_scheduler_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'om_timeslot_scheduler'),
  );
}

/**
 * Implementation of hook_perm().
 */
function om_timeslot_scheduler_perm() {
  return array('access scheduling options of own shows', 'access scheduling options of aired shows', 'access scheduling options of all shows', 'manage scheduling', 'administer scheduling', 'administer Open Media System');
} // function om_timeslot_scheduler_perm



/**
 * Implementation of hook_help().
 */
function om_timeslot_scheduler_help($section) {
  switch ($section) {
    case 'admin/help#timeslot_scheduler':
      return t('Core scheduling functions.');
      break;
  }
}


/**
 * Implementation of hook_node_info().
 */
function om_timeslot_scheduler_node_info() {
  return array(
    'om_timeslot_event' => array(
      'name' => t('Timeslot Event'),
      'module' => 'om_timeslot_scheduler',
    ),
    'om_timeslot_theme' => array(
      'name' => t('Timeslot Theme'),
      'module' => 'om_timeslot_scheduler',
    ),
  );
}

/**
 * Implementation of hook_form().
 *
 */
function om_timeslot_scheduler_form(&$node, $form_state) {
  $type = node_get_types('type', $node);

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $node->title,
      '#weight' => -5
    );
  }

  if ($type->has_body) {
    $form['body_field'] = node_body_field($node, $type->body_label, $type->min_word_count);
  }

  return $form;
}




/**
 * Implementation of hook_menu().
 */
  
function om_timeslot_scheduler_menu() {
  $items = array();
  
  // Adds Open Media Section to Admin Interface
  // Duplicated in om_show, om_project
  $items['admin/openmedia'] = array(
    'title' => 'Open Media System',
    'description' => 'Administration and configuration options for Open Media System.',
    'position' => 'right',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer Open Media System'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'weight' => -20,
  );
  
  $items['admin/openmedia/om-timeslot-scheduler'] = array(
    'title' => 'Scheduling Configuration',
    'description' => 'Configuration options for the Open Media Timeslot Scheduler.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('om_timeslot_admin_settings'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  
  $items['admin/openmedia/om-timeslot-scheduler/remount/%node'] = array(
    'title' => 'Remount Playback Server',
    'description' => 'Attempts to remount playback server mount point using Apache user.',
    'page callback' => 'om_timeslot_playback_server_remount',
    'page arguments' => array(4),
    'access arguments' => array('access administration pages'),
    'type' => MENU_CALLBACK,
  );
  
  $items['om-timeslot-scheduler/styles'] = array(
    'title' => 'Returns CSS for timeslots',
    'description' => 'Returns CSS for timeslots',
    'page callback' => 'om_timeslot_theme_styles',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
   );
   
   $items['om-timeslot-scheduler/add/show/%node'] = array(
    'title' => 'Moving Video and Metadata to Playback Server',
    'description' => 'Takes node ID and channel tid.  Returns confirmation video and metadata have been transfered',
    'page arguments' => array(3, 4),
    'page callback' => 'om_timeslot_scheduler_add_show',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
   );
   
   $items['om-timeslot-scheduler/self_schedule_airing'] = array(
     'title' => 'Self Schedule Airing',
     'description' => 'Use OPS to allow users to self schedule an airing.',
     'page arguments' => array(2, 3, 4, 5),
     'page callback' => '_om_timeslot_scheduler_find_openings',
     'access arguments' => array('access content'),
     'type' => MENU_CALLBACK,
   );
   
   $items['om-timeslot-scheduler/find/openings/%node'] = array(
    'title' => 'Openings in Timeslot longer than the Duration of this Show',
    'description' => 'Takes node ID, timeslot ID. Returns openings',
    'page arguments' => array(3, 4),
    'page callback' => 'om_timeslot_scheduler_find_openings',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
   );
   
   $items['timeslots/bychannel'] = array(
    'title' => 'Scheduling Options by Channel',
    'page callback' => 'om_timeslot_channel_selector_result',
    'page arguments' => array(2, 3),
    'access arguments' => array('access administration pages'),
    'type' => MENU_LOCAL_TASK,
   );

   $items['node/%node/airing-options'] = array(
    'title' => 'Scheduling Options',
    'description' => 'Takes node ID and returns options scheduling based on project and themes',
    'page callback' => 'om_timeslot_airing_options',
    'page arguments' => array(1),
    'access callback' => 'om_timeslot_airing_options_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,

   );
   
   $items['node/%node/playback-status'] = array(
    'title' => 'Status',
    'description' => 'Takes node ID and returns the server status variables based on sub_module functionality',
    'page callback' => 'om_timeslot_playback_server_status',
    'page arguments' => array(1),
    'access callback' => 'om_timeslot_playback_server_status_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,

   );
   
   // Adds Manage Scheduling to Admin Interface
  $items['admin/om-timeslot-scheduler/manage'] = array(
    'title' => 'Manage Scheduling',
    'description' => 'Manage Scheduling of Open Media Shows onto Playback Servers',
    'position' => 'right',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('manage scheduling'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'weight' => -17,
  );
  
  $items['admin/om-timeslot-scheduler/manage/default'] = array(
    'title' => 'Overview',
    'description' => 'Dashboard of options for Scheduling',
    'page callback' => 'om_timeslot_scheduler_manage',
    'access arguments' => array('manage scheduling'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 20,
  );
  
  $items['admin/om-timeslot-scheduler/manage/themes'] = array(
    'title' => 'Manage Timeslot Themes',
    'description' => 'Configure Timeslot Themes',
    'page callback' => 'om_timeslot_scheduler_manage_themes',
    'access arguments' => array('manage scheduling'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );
  
  $items['admin/om-timeslot-scheduler/manage/events'] = array(
    'title' => 'Manage Timeslot Events',
    'description' => 'f of Timeslot Events',
    'page callback' => 'om_timeslot_scheduler_manage_events',
    'access arguments' => array('manage scheduling'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  
  return $items;
  
}

/**
 * Builds the Timeslot Scheduler admininstration settings form.
 */
function om_timeslot_admin_settings() {
  $form = array();
  
  $channels = om_timeslot_scheduler_get_channels();
 
  
  //Check to see if om_show and om_broadcast_sync are installed and configured.  While Timeslot Scheduler does not require these modules, it will not be bale to do much until they are installed and configured
  
  if (!module_exists('om_show')) {
     $status_message = $status_message . '<p><a href="http://drupal.org/project/om_show">Open Media Show</a> is not installed.  While you can configure Timeslot Themes and Events without Show, Timeslow Scheduler is designed to schedule Shows.</p>';
  }
  /* I'm guessing we can remove this now that we are on airings and om_broadcast_sync is deprecated (?) */
  if (!module_exists('om_broadcast_sync')) {
     $status_message = $status_message . '<p><a href="http://drupal.org/project/om_show">Open Media Broadcast Synchronization</a> is not installed.  While you can configure  Timeslot Themes and Eventsn, you will not be able to accurately determine what is already scheduled on your playback servers without installing and configuring Broadcast Synchronization.</p>';
  }
  
  if (module_exists('om_timeslot_princeton')||module_exists('om_timeslot_cablecast')||module_exists('om_timeslot_synergy')||module_exists('om_timeslot_leightronix')||module_exists('om_timeslot_maestrovision')) {
     $status_message = $status_message . '<p>At least one playback server specific sub module is installed.</p>';
  } 
  else {
     $status_message = $status_message . '<p>There are no playback server specific sub modules installed.</p>';
  }
  
  $form['om_timeslot_scheduler_user_scheduled_first_airing'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow users to schedule first airings'),
    '#default_value' => variable_get('om_timeslot_scheduler_user_scheduled_first_airing', ''),
    '#description' => t('Producers will be given scheduling options when new Shows are added.'),
  );

  $form['om_timeslot_scheduler_admin_scheduled_first_airing'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow project administrators to schedule first airings for all shows in project'),
    '#default_value' => variable_get('om_timeslot_scheduler_admin_scheduled_first_airing', ''),
    '#description' => t('Project administrators will be given scheduling options when new Shows are added.'),
  );
  
  $form['om_timeslot_scheduler_first_airing_channel'] = array(
    '#type' => 'select',
    '#title' => t('Default Airing on Channel'),
    '#options' => $channels,
    '#default_value' => variable_get('om_timeslot_scheduler_first_airing_channel', ''),
    '#description' => t('New Shows will be have their first airing scheduled to Timeslot Events marked as User Schedulable on this channel.'),
  );
  
  $form['om_timeslot_scheduler_number_of_airing_options'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of Airing options producers are shown'),
    '#default_value' => variable_get('om_timeslot_scheduler_number_of_airing_options', '3'),
    '#description' => t('Producers are given a few options for their initial airing.'),
  );
  
  $form['om_timeslot_scheduler_hours_between_airing_options'] = array(
    '#type' => 'textfield',
    '#title' => t('Minimum hours between Airing options'),
    '#default_value' => variable_get('om_timeslot_scheduler_hours_between_airing_options', '7'),
    '#description' => t('After finding the first available airing time, the system will move forward this number of hours before looking for another opening.  This is designed to give some variation in the airing options between primetime, late night, and early morning hours.  If the first available airing is at 3AM and the system is set for a minimum of 7 hours, it will look for the next available time to air this program after 10AM.'),
  );
  
  $form['om_timeslot_scheduler_minutes_since_cron'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum Minutes Since Cron'),
    '#default_value' => variable_get('om_timeslot_scheduler_minutes_since_cron', '15'),
    '#description' => t('If cron has not run within this many minutes, scheduling options are disabled.  This is to ensure a current version of the schedule exists preventing the user from scheduling over an existing show.  Set to 0 to ignore cron when scheduling.'),
  );
  
  $form['om_timeslot_scheduler_cron_error'] = array(
    '#type' => 'textarea',
    '#title' => t('Cron Error'),
    '#default_value' => variable_get('om_timeslot_scheduler_cron_error', 'Scheduling options are disabled because the Playback server\'s schedule has not been synchronized since ***lastcron***.  Without a current version of the schedule, your show could be scheduling over an existing show.  If you continue to get this error for several hours, contact the site Administrator.'),
    '#description' => t('Cron plays an important role in scheduling, but most producers have no ideas what cron is.  This allows you to customize the error they see when they are prevented from scheduling due to cron issues.'),
  );
  
  $form['om_timeslot_scheduler_self_max_days'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum Number of Days in Advance a User can Self Schedule'),
    '#default_value' => variable_get('om_timeslot_scheduler_self_max_days', '7'),
    '#description' => t('This will limit the display of available Timeslots to this number of day in advance.  Set to 0 to ignore when scheduling.'),
  );
  
  $form['om_timeslot_scheduler_self_max_days_for_project'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum Number of Days in Advance a User can Self Schedule a Series'),
    '#default_value' => variable_get('om_timeslot_scheduler_self_max_days_for_series', '30'),
    '#description' => t('This will extend the display of available Timeslots to this number of day in advance for Timeslots associated to a Project.  Set to 0 to ignore when scheduling.'),
  );
  
    $form['om_timeslot_scheduler_limit_to_project_slots'] = array(
    '#type' => 'checkbox',
    '#title' => t('Project Timeslots Only'),
    '#default_value' => variable_get('om_timeslot_scheduler_limit_to_project_slots', '0'),
    '#description' => t('If this setting is checked, non-admin users will only see options for scheduling a show into a Project Timeslot if any Project Timeslots exist.'),
  );
  
  $hours_description = t('<div>Enter military time for both start and end time of when adult content should be blocked, separated by a dash, in the format <em>hh:mm-hh:mm</em></div>ex. <em>05:00-22:00</em> would block adult content from 5AM to 10PM. Leave blank to allow adult content to be scheduled at any time.');
  
  $form['om_timeslot_scheduler_adult_block_hours'] = array(
    '#type' => 'textfield',
    '#title' => t('Block Adult Content During These Hours'),
    '#default_value' => variable_get('om_timeslot_scheduler_adult_block_hours', '05:00-22:00'),
    '#description' => $hours_description,
  );
  
  
  
  return system_settings_form($form); 
}

/**
 * Implementation of hook_form_alter().
 */
function om_timeslot_scheduler_form_alter(&$form, $form_state, $form_id) {

  // Node add/edit forms.
  if (isset($form['type']) && isset($form['#node'])) {
    $type = $form['type']['#value'];
    if ($form_id == 'om_timeslot_event_node_form' || $form_id == 'om_timeslot_theme_node_form' || $form_id == 'om_timeslot_server_node_form') {  
    
     $node = (object) $form['#node'];
     
     $timeslot_rules = db_query("SELECT n.title FROM {node} n WHERE n.type = '%s' AND n.status = %d ORDER BY n.title", 'om_timeslot_rule', 1);

        while ($timeslot_rule = db_fetch_object($timeslot_rules)) {
          $rules = $rules . $timeslot_rule->title . ', ';
        } // while
            
     $form['om_timeslot_rule_list'] = array(
            '#type' => 'fieldset',
            '#title' => t('Available Timeslot Rules'),
            '#collapsible' => TRUE,
            '#collapsed' => FALSE,
            '#weight' => 1,
            '#description' => $rules,
          );
    } 
  }
  
}

function om_timeslot_scheduler_themes() {

  $result = db_query("SELECT title FROM {node} n JOIN {content_type_om_timeslot_theme} ct ON n.vid = ct.vid WHERE type = 'om_timeslot_theme'");

  return db_fetch_object($result);
}

function om_timeslot_scheduler_theme_stats($theme_id, $date) {

  if ($date) {
    $result = db_query("SELECT count(c.vid) as total FROM {content_field_om_theme} c JOIN {node} n ON n.vid = c.vid WHERE field_om_theme_nid = %d AND created > '%s'", $theme_id, $date);
  } 
  else {
  $result = db_query("SELECT count(c.vid) as total FROM {content_field_om_theme} c WHERE field_om_theme_nid = %d", $theme_id);
  }
   $theme_total = db_fetch_object($result);
   
  return $theme_total->total;
}

function om_timeslot_scheduler_theme_duration($theme_id, $date) {

  if ($date) {  
    $result = db_query("SELECT field_om_show_duration_value FROM {content_type_om_show} c JOIN {node} n ON n.vid = c.vid JOIN {content_field_om_theme} cf ON c.nid = cf.nid WHERE field_om_theme_nid = %d AND created > '%s'", $theme_id, $date);
  } 
  else {
    $result = db_query("SELECT field_om_show_duration_value FROM {content_type_om_show} c JOIN {content_field_om_theme} cf ON c.nid = cf.nid WHERE field_om_theme_nid = %d", $theme_id);
  }
  
  while ($theme_total = db_fetch_object($result)) {
    $duration = $duration + $theme_total->field_om_show_duration_value; 
  }
   
  return $duration;
}

function om_timeslot_scheduler_event_duration($theme_id, $startdate, $enddate) {

  if ($startdate) {
    //2010-02-16 14:44:24
    $formatdate = date("y-m-d", $startdate) . ' 00:00:00'; 
    $result = db_query("SELECT field_om_timeslot_date_value, field_om_timeslot_date_value2 FROM {content_type_om_timeslot_event} JOIN {content_field_om_timeslot_date} ON content_type_om_timeslot_event.vid = content_field_om_timeslot_date.vid JOIN {content_field_om_theme} cf ON content_type_om_timeslot_event.nid = cf.nid WHERE field_om_theme_nid = %d AND field_om_timeslot_date_value > '%s'", $theme_id, $date);
  } 
  else {
    $result = db_query("SELECT field_om_timeslot_date_value, field_om_timeslot_date_value2 FROM {content_type_om_timeslot_event} JOIN {content_field_om_timeslot_date} ON content_type_om_timeslot_event.vid = content_field_om_timeslot_date.vid JOIN {content_field_om_theme} cf ON content_type_om_timeslot_event.nid = cf.nid WHERE field_om_theme_nid = %d", $theme_id);
  }
  
  while ($theme_total = db_fetch_object($result)) {
    $duration = $duration + (strtotime($theme_total->field_om_timeslot_date_value2.' UTC') - strtotime($theme_total->field_om_timeslot_date_value.' UTC')); 
  }
   
  return $duration;
}

/**
 * Used to add the CSS to the timeslot calendar.
 */
function om_timeslot_theme_styles() {
   if (user_access('administer scheduling') || user_access('administer Open Media System')) {
     $result = db_query("SELECT node.nid as nnid,field_om_timeslot_theme_color_value, title FROM {content_type_om_timeslot_theme} JOIN {node} ON node.vid = content_type_om_timeslot_theme.vid");
   } 
   else {
     $result = db_query("SELECT node.nid as nnid,field_om_timeslot_theme_color_value, title FROM {content_type_om_timeslot_theme} JOIN {node} ON node.vid = content_type_om_timeslot_theme.vid WHERE status > 0");
   }
  
  $result = db_query("SELECT node.nid as nnid,field_om_timeslot_theme_color_value, title FROM {content_type_om_timeslot_theme} JOIN {node} ON node.vid = content_type_om_timeslot_theme.vid");
  
  print '<style>';
  
  while ($om_theme = db_fetch_object($result)) {
     $timeslot_theme = str_replace(array('&', ',', ' ', '/'), array('', '', '-', ''), strtolower($om_theme->title));
     print '.theme-' . $timeslot_theme . ' div , .theme-' . $timeslot_theme . ' div a { ' . "\n" . ' background-color: ' . $om_theme->field_om_timeslot_theme_color_value . ' !important;' . "\n" . '}' . "\n";
  }
  print '</style>';
}

/**
 * Adds the HTML key to the Timeslot Calendar
 */
function om_timeslot_theme_style_key() {
  global $base_path;
   if (user_access('administer scheduling') || user_access('administer Open Media System')) {
     $result = db_query("SELECT node.nid as nnid,field_om_timeslot_theme_color_value, title FROM {content_type_om_timeslot_theme} JOIN {node} ON node.vid = content_type_om_timeslot_theme.vid  ORDER BY title");
   } 
   else {
     $result = db_query("SELECT node.nid as nnid,field_om_timeslot_theme_color_value, title FROM {content_type_om_timeslot_theme} JOIN {node} ON node.vid = content_type_om_timeslot_theme.vid WHERE status > 0 ORDER BY title");
  }

  $output_array = array();
  $count = 0;
  while ($om_theme = db_fetch_object($result)) {
     
     $timeslot_theme = str_replace(array('&', ',', ' ', '/'), array('', '', '-', ''), strtolower($om_theme->title));
     $output_array[$count] = '<div class="theme-' . $timeslot_theme . '"><div style="float:left; width: 20px;">&nbsp;</div>&nbsp; ' . l($om_theme->title, 'node/' . $om_theme->nnid) . '</div>';
     
     $count++;
  }
  
  $loopcount = 0;
  if (count($output_array)) {
    $halfoutput = round(count($output_array)/3);
    $output .= '<table width="100%"><tr><td valign="top">';
      foreach ($output_array as $i => $value) {
        $output .= $output_array[$i];
        if ($halfoutput==$loopcount) {
          $output .= '</td><td valign="top">';
          $loopcount = 0;
        }
        $loopcount++;
      }
    
    $output .= '</td></tr></table>';
    
  }
  
  return $output;
}

/**
 * Builds the Timeslot Scheduler admininstration settings form.
 */
function om_timeslot_scheduler_add_show($node, $channel_tid) {
   $server = om_timeslot_scheduler_get_servers($channel_tid);
   
   if ($server->field_om_timeslot_server_type_value == 'princeton' && module_exists('om_timeslot_princeton')) {
     if ( user_access('access scheduling options of own shows') || user_access('access scheduling options of all shows') || user_access('manage scheduling') || user_access('administer scheduling') || user_access('administer Open Media System') ) {
       $output .= om_timeslot_princeton_transfer($node, $channel_tid);
     } 
     else {
       $output .= t('You do not have permission schedule this show.');
     }
   } 
   else {
     $output .= t('om_timeslot_princeton is not enabled');
   }
   
   print theme('page', $output);
}

/**
 * Adds the Airing to the playback server and creates a temp om_airing record
 */
function om_timeslot_scheduler_check_existing($nid, $channel) {
    
    //NEEDS TO LOOKUP WHICH SERVER FUNCTION TO CALL BASED ON CHANNEL
    om_timeslot_princeton_check_existing($nid, $channel);
}

/**
 * om_timeslot_channel_selector_form_handler()
 * AHAH form handler for om_timeslot_airing_options_channel_selector
 */

function om_timeslot_channel_selector_form_handler($form) {
   
   $channel = $form['channel-selector']['#value'];
   $nid = $form['channel-selector']['#storage'];
   
   drupal_goto('timeslots/bychannel/' . $nid . '/' . $channel);
}

function om_timeslot_channel_selector_result($nid, $channel) {
  
  global $user;
  
  $show_title = db_result(db_query('SELECT title FROM {node} WHERE nid = %d', $nid));
  
  $channel_number = om_playback_servers_get_channel_number_from_tid($channel);
  
  drupal_set_title('Timeslots for ' . $show_title . ' on ' .$channel_number);
  
  $timeslots = om_timeslot_generate_available_self_scheduling_timeslots($nid, $channel);
  $output = '<p>';
  if($timeslots) {
    foreach ($timeslots AS $key => $value) {
      // Watch for series and plan accordingly.
      if(preg_match('/s-/', $key)) {
        $series_links .= $value . '- ' . l('Schedule It!', 'om-timeslot-scheduler/find/openings/' . $nid . '/' . trim(str_replace('s-', '', $key))) . '<br />';
      } else {
        $theme_links .= $value . '- ' . l('Schedule It!', 'om-timeslot-scheduler/find/openings/' . $nid . '/' . $key) . '<br />';
      }
    }
    // If you wanted everyone to be able to schedule all available timeslots you could change/remove this check
    if ($user->uid == 1 || in_array('staff', $user->roles) || in_array('interns', $user->roles)) {
      $series_links = $series_links ? $series_links : 'There are no series timeslots available.';
      $output .= '<h3>Series Timeslots For This Show</h3>' . $series_links . '<h3>Theme Timeslots For This Show</h3>' . $theme_links;
    } 
    else {
      if ($series_links) {
        $output .= '<h3>Series Timeslots For This Show</h3>' . $series_links;
      } else {
        $output .= 'Your show seems to have no series timeslots available. Here are some options based on your show\'s theme: <h3>Theme Based Timeslots For This Show</h3>' . $theme_links;
      }
    }
  }
  else {
    $output .= t('There has been an a system error, please contact station staff. There are no timeslots available for your show.');
  }
   $output .= '</p>';
  print theme('page', $output);

}

/**
 * om_timeslot_airing_options_channel_selector(&$form_state)
 * Generate airing options form if you are privy to see it.
 * @returns $form drupal standard form array.
 */

function om_timeslot_airing_options_channel_selector() {
  
  global $user;
  
  // If you are of the correct role choose a channel.
  if (user_access('manage scheduling') || user_access('administer scheduling')) {
    
    $channels = om_playback_servers_get_channel_taxonomy();
    
    foreach ($channels AS $value) {
      $channels_options[$value->tid] = $value->name;
    }
    
    $form['#cache'] = TRUE;
    
    $form['channel-selector'] = array(
      '#title' => 'Select a channel to self-schedule',
      '#description' => 'Select a channel to schedule.',
      '#type' => 'select',
      '#options' => $channels_options,
      '#default_value' => variable_get('om_timeslot_scheduler_first_airing_channel'),
      '#storage' => arg(1),
    );
    
    $form['channel-submit'] = array(
      '#type' => 'submit',
      '#value' => 'submit',
    );
    
    $form['#submit'][] = 'om_timeslot_channel_selector_form_handler';
    
  } 
  // Otherwise use default.
  else {
    
    $channel = variable_get('om_timeslot_scheduler_first_airing_channel', NULL);
    
    $timeslots = om_timeslot_generate_available_self_scheduling_timeslots(arg(1), $channel);
    if($timeslots) {
      foreach ($timeslots AS $key => $value) {
        $options .= $value . '- ' . l('Schedule It!', 'om-timeslot-scheduler/find/openings/' . arg(1) . '/' . $key) . '<br />';
      }
    }
    
    $form['channel-selector'] = array(
      //@TODO: GENERALIZE 56
      //'#prefix' => '<b>You are currently scheduling on DOM 56</b><br/>',
      '#value' => 'Please select a Timeslot below. <br/>' . $options,
    );

  }
  
  return $form;
  
}

/**
 * om_timeslot_generate_available_self_scheduling_timeslots($nid, $channel_tid)
 * Given the show nid and channel tid generate a list of matching theme based timeslots.
 * @param $nid, show nid
 * @param $channel_tid, tid of desired channel
 * @returns $timeslots array of available timelots in the format: $timeslots[tid] = name.
 */


function om_timeslot_generate_available_self_scheduling_timeslots($nid, $channel_tid) {
  
  $node = node_load($nid);
  
  // @TODO: Why were these seperate queries?
  //$is_adult_audience = db_result(db_query('SELECT field_om_rating_value FROM {content_field_om_rating} WHERE nid = %d', $nid)) == 'TV-MA' ? TRUE : FALSE;
  //$group_nid = db_result(db_query('SELECT group_nid FROM {og_ancestry} WHERE nid = %d', $nid));
  
  $is_adult_audience = $node->field_om_rating[0]['value'] == 'TV-MA' ? TRUE : FALSE;  
  $group_nid = reset($node->og_groups);
  
  $series_timeslot_query = db_query("SELECT node.nid, title  FROM {content_type_om_timeslot_event} JOIN {node} ON node.vid = content_type_om_timeslot_event.vid JOIN {term_node} ON node.nid = term_node.nid WHERE field_om_project_nid = %d AND tid = %d", $group_nid, $channel_tid);
  
  while ($series_timeslot = db_fetch_array($series_timeslot_query)) {
    
    $timeslots['s-' . $series_timeslot['nid']] = $series_timeslot['title'];
    
  }
  
  if (module_exists('om_timeslot_pairings')) {
    
    $show_theme = db_result(db_query('SELECT field_om_theme_nid FROM {content_field_om_theme} WHERE nid = %d', $nid));
    
    $show_pair = db_result(db_query('SELECT pairing_nid FROM {om_timeslot_pairings} WHERE theme_nid = %d', $show_theme));
    
    $result = db_query("SELECT node.nid, title, field_om_timeslot_date_value, field_om_timeslot_date_value2 FROM {content_type_om_timeslot_event} JOIN {node} ON node.vid = content_type_om_timeslot_event.vid JOIN {content_field_om_timeslot_date} ON content_field_om_timeslot_date.vid = node.vid JOIN {content_field_om_theme} cf ON node.nid = cf.nid LEFT JOIN {term_node} ON content_type_om_timeslot_event.nid = term_node.nid WHERE (
cf.field_om_theme_nid = %d OR cf.field_om_theme_nid = %d ) AND node.status = 1 AND term_node.tid = %d GROUP BY title", $show_theme, $show_pair, $channel_tid);
    
    while ($timeslot_event = db_fetch_array($result)) {
      if(!$is_adult_audience) {
      
        $timeslots[$timeslot_event['nid']] = $timeslot_event['title'];
      
      }
      else {
        
        $start_time_of_event = date('G', strtotime($timeslot_event['field_om_timeslot_date_value'] . 'UTC'));
        $end_time_of_event = date('G', strtotime($timeslot_event['field_om_timeslot_date_value2'] . 'UTC'));
        
        if($start_time_of_event >= 22 && ($end_time_of_event == 23 || $end_time_of_event <= 6)) {
        
          $timeslots[$timeslot_event['nid']] = $timeslot_event['title'];
        
        }
      }
    }
    
  } else {
    
    //dsm('not using pairings');
    //dsm($nid);
    
    $show_theme = $node->field_om_theme[0]['nid'];
    //$show_theme = db_result(db_query('SELECT field_om_theme_nid FROM {content_field_om_theme} WHERE nid = %d'), $nid);
    
    //dsm('show theme:');
    //dsm($show_theme);
    //dsm('channel:');
    //dsm($channel_tid);
    
    //SELECT node.nid, title, field_om_theme_nid  FROM `term_node` JOIN node ON node.nid = term_node.nid JOIN content_field_om_theme cf ON node.nid = cf.nid WHERE `tid` = 344 AND type = 'om_timeslot_event' AND field_om_theme_nid = 2123
    
    $result = db_query("SELECT node.nid, title, field_om_timeslot_date_value, field_om_timeslot_date_value2 FROM {content_type_om_timeslot_event} JOIN {node} ON node.vid = content_type_om_timeslot_event.vid JOIN {content_field_om_timeslot_date} ON content_field_om_timeslot_date.vid = node.vid JOIN {content_field_om_theme} cf ON node.nid = cf.nid LEFT JOIN {term_node} ON content_type_om_timeslot_event.nid = term_node.nid WHERE
cf.field_om_theme_nid = %d  AND node.status = 1 AND term_node.tid = %d GROUP BY title", $show_theme , $channel_tid);


    
    while ($timeslot_event = db_fetch_array($result)) {
      if(!$is_adult_audience) {
      
        $timeslots[$timeslot_event['nid']] = $timeslot_event['title'];
      
      }
      else {
        
        $start_time_of_event = date('G', strtotime($timeslot_event['field_om_timeslot_date_value'] . 'UTC'));
        $end_time_of_event = date('G', strtotime($timeslot_event['field_om_timeslot_date_value2'] . 'UTC'));
        
        if($start_time_of_event >= 22 && ($end_time_of_event == 23 || $end_time_of_event <= 6)) {
          
          $timeslots[$timeslot_event['nid']] = $timeslot_event['title'];
          
        }
      }
    }
  }
  
  return $timeslots ? $timeslots : array();
  
}

/**
 * Shows user the Timeslot Events that match their Theme or Project
 */
function om_timeslot_airing_options($node) {
  
  global $user;
  global $base_path;
  
  if ($node->field_om_show_aired[0]['value'] && !user_access('access scheduling options of aired shows')) {
    $output .= '<div class="messages error">' . t('Sorry.  This show has either already aired or is scheduled to air soon.  If you want this show to air again, get everyone you know to vote for it!') . '</div>';
  } 
  else {
  
    $lastcron = variable_get('cron_last', '');
    $humandate = date("F j, Y, g:i a", $lastcron);
    $sincecron = round((time() - $lastcron)/60);
    
    $output .= '<div class="message">Playback server schedule last synchronized: ' . date("F j, Y, g:i a", $lastcron) . ' (' . $sincecron . ' minutes ago)</div>';
    
    $cron_tolerance = variable_get('om_timeslot_scheduler_minutes_since_cron', 0);
    
    //If cron tolerance is set to 0, don't bother checking
    if ($cron_tolerance) {
      if ($cron_tolerance < $sincecron) {
        $cron_error = TRUE;
      } 
      else {
        $cron_error = FALSE;
      }
    } 
    else {
      $cron_error = FALSE;
    }
    
    if ($cron_error) {
      // @TODO: Cahnge to use token
      $error = variable_get('om_timeslot_scheduler_cron_error', 'error');
      $output = $output . '<div class="messages error">' . str_replace('***lastcron***', $humandate, $error) . '</div>';
    } 
    else {
      
      if ($node->field_om_show_aired[0]['value'] && !user_access('access scheduling options of aired shows')) {
        $output = $output . '<div class="messages error">' . t('This show has already aired.  It can only be rescheduled by users with administrative scheduling permissions.') . '</div>';
        
      } 
      else {
       
       $output .= drupal_get_form('om_timeslot_airing_options_channel_selector');
       
      }
    }
  } // end if aired
  
print theme('page', $output);
 
}

/**
 * Checks om_airings for existing airings.  Displays possible start times.
 */
function om_timeslot_scheduler_find_openings($node, $timeslot_nid) {
  global $user;
  
  date_default_timezone_set('UTC');
  //$interval_between_scheduling = 1800; //seconds
  //$interval_between_airings = 86400; // seconds
  
  // First check to see if the show in question has been scheduled within 30 minutes.
  
  //$last_airing = db_result(db_query('SELECT MAX(node.changed)FROM `node` join content_type_om_airing AS airing ON airing.nid = node.nid WHERE field_om_airing_mpeg2_value = "%S" AND node.type = "om_airing"', $node->field_om_show_mpeg2[0]['filename']));
  
  if(user_access('manage scheduling') ||  user_access('administer scheduling') || $user->uid == 1){
    //bypass
  }
  else{
    
    //@TODO: This should be changed to check nid against node_reference in om_airing
    //$last_airing = db_result(db_query('SELECT MAX(nid) FROM {content_type_om_airing} WHERE field_om_airing_mpeg2_value = "%s"', trim($node->field_om_show_mpeg2[0]['filename'])));
    
    //$last_airing = db_result(db_query('SELECT MAX(nid) FROM {content_type_om_airing} WHERE field_om_airing_filename_value = "%s"', trim($node->field_om_show_mpeg2_path[0]['value'])));
    
    $last_airing = db_result(db_query('SELECT MAX(nid) FROM {content_type_om_airing} WHERE field_om_airing_mpeg2_value = "%s"', trim($node->field_om_show_mpeg2_path[0]['value'])));
    
    
    if($last_airing){
       $output .= '<p>This show has already been scheduled once. If you would like to schedule it again, please contact station personnel.</p>';
       print theme('page', $output);
       return;
    }
  }
  
  if (module_exists('om_timeslot_pairings')) {
    /* temp */
    $output .= '<div><h3>Schedule Your Show</h3>';
    $output .= 'Trying to schedule ' . $node->title . '<br />';
    $output .= 'Duration: ' . $node->field_om_show_duration[0]['value'] . ' seconds<br />';
    
    // For Error Tracking -- Need to detect if file is too big or if there are no gaps.
    $limit_by = 4;
    $current_timeslot = 0;
    $openings_status = NULL; // tristate 'Success', 'Too Big', 'No Gaps'
    
    $result = db_query("SELECT * FROM {content_field_om_timeslot_date} otdv JOIN {term_node}  ON otdv.nid = term_node.nid JOIN {content_type_om_timeslot_event} ote ON otdv.nid = ote.nid WHERE otdv.nid = %d AND field_om_timeslot_date_value > NOW() AND ote.field_om_timeslot_userscheduled_value = 1 ORDER BY field_om_timeslot_date_value LIMIT 0, %d", $timeslot_nid, $limit_by);
    
    // Wish there was a cleaner way to do all this over endless looping.
    
    while ($timeslottheme = db_fetch_object($result)) {
      
      $channel_tid = $timeslottheme->tid;
      $channel_number = om_playback_servers_get_channel_number_from_tid($channel_tid);
      
       //Update airings for our time range.
      om_playback_servers_update_schedule($channel_number, strtotime($timeslottheme -> field_om_timeslot_date_value), strtotime($timeslottheme -> field_om_timeslot_date_value2));
      // call purge
      om_timeslot_purge_temp_airings($start, $end, $channel_tid);

      $current_timeslot ++;
      $channel = om_timeslot_scheduler_get_channel_name($timeslottheme->tid);
      // Anticipate Series: Essentialy operate as if pairings is turend off for this timeslot.
      // $is_series_nid just prevents repetion since series timeslot nids seem to all be the same;
      
      if ($timeslottheme->field_om_timeslot_theme_nid == NULL) {
        // get the gaps
        $gaps = om_timeslot_scheduler_find_timeslot_event_openings($timeslot_nid, strtotime($timeslottheme -> field_om_timeslot_date_value), strtotime($timeslottheme -> field_om_timeslot_date_value2), $channel_tid);
        //loop through gaps
        for ($i = 0; $i < count($gaps); $i++) {
          if ($gaps[$i]['start'] >= strtotime($timeslottheme -> field_om_timeslot_date_value + 'UTC')) {
            if ($gaps[$i]['start']+$node->field_om_show_duration[0]['value'] <= $gaps[$i]['end']) {
             $openings_status = 'Success';
              if ($gaps[$i]['first_airing'] == 1) {
                  $scheduling_links = $scheduling_links . l('Schedule series to start ' . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']) . '/' . $channel_tid) . '<br />';
              }
              else { 
                  $scheduling_links = $scheduling_links . l('Schedule series to start ' . $lead['title'] . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/'  . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']) . '/' . $channel_tid) . ' * <br />';
              }
            }
            else {
              // Too Long
              $openings_status = 'Too Long';
            }
          }
          else{
             // no gaps
             $openings_status = 'No Gaps';
          }
        } // end for
        $is_series_nid = $timeslot_nid;
       }
      
      $lead_nid = $timeslottheme->field_om_timeslot_theme_nid;
      $pairing_nid = db_result(db_query("SELECT pairing_nid FROM {om_timeslot_pairings} WHERE theme_nid = %d", $lead_nid));
      
      // build theme pair node object 
      $theme_pair -> field_om_timeslot_lead_last_value = $timeslottheme -> field_om_timeslot_lead_last_value;
      $theme_pair -> pairing_nid = $pairing_nid;
      $theme_pair -> theme_nid = $lead_nid;
      
      // build timeslot event object from above query. 
      $te_node -> field_om_timeslot_date[0]['value'] = $timeslottheme -> field_om_timeslot_date_value;
      $te_node -> field_om_timeslot_date[0]['value2'] = $timeslottheme -> field_om_timeslot_date_value2;
      
      // pass both nodes to om_timeslot_pairings_calculate_pair_times and get pairing times
      $pairing_times = om_timeslot_pairings_calculate_pair_times($te_node, $theme_pair);
      
      // get pairing ends from returned times
      $lead['start'] = $pairing_times['leadstart']; 
      $lead['end'] = $pairing_times['pairstart']; // leaves no gap between lead and pairing is this correct?
      $lead['nid'] = $pairing_times['leadnid'];
      $lead['title'] = db_result(db_query('SELECT title FROM {node} WHERE nid = %d', $lead['nid']));
      
      // paring end time = end of time slot event. I think this should work. Don't forget UTC conversion!
      $timeslot_end = strtotime($timeslottheme -> field_om_timeslot_date_value2.' UTC');
      
      $pairing['start'] = $pairing_times['pairstart'];
      $pairing['end'] = $timeslot_end; //presumes pairing goes all the way to the end of the timeslot.
      $pairing['nid'] =  $pairing_times['pairnid'];
      $pairing['title'] = db_result(db_query('SELECT title FROM {node} WHERE nid = %d', $pairing['nid']));
      
      // determine if show has theme lead or pairing
      $show_theme = $node->field_om_theme[0]['nid'];
      
      $gaps = om_timeslot_scheduler_find_timeslot_event_openings($timeslot_nid, strtotime($timeslottheme -> field_om_timeslot_date_value), strtotime($timeslottheme -> field_om_timeslot_date_value2), $channel_tid);
      if ($show_theme == $lead['nid'] && $lead['nid'] !== NULL) {
        // show has the lead theme in this timeslot
        //loop through gaps
        for ($i = 0; $i<count($gaps); $i++) {
          if ($gaps[$i]['start'] >= $lead['start']) {
            if ($gaps[$i]['start']+$node->field_om_show_duration[0]['value'] <= $gaps[$i]['end'] && $gaps[$i]['start']+$node->field_om_show_duration[0]['value'] <= $lead['end']) {
              $openings_status = 'Success';
              if ($gaps[$i]['first_airing'] == 1) {
                $scheduling_links = $scheduling_links . l('Schedule to start in lead theme ' . $lead['title'] . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']) . '/' . $channel_tid) . '<br />';
              
              }
              else {
                $scheduling_links = $scheduling_links . l('Schedule to start in lead theme ' . $lead['title'] . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']). '/' . $channel_tid) . ' * <br />';
              }
            }
            else{
              // too long
              $openings_status = 'Too Long';
            }
          }
          else{
             // no gaps
             $openings_status = 'No Gaps';
          }
        } // end for
      }// end if lead
      
      if ($show_theme == $pairing['nid'] && $pairing['nid'] != NULL) {
        // show has the pairing theme in this timeslot
        //loop through gaps
        for ($i = 0; $i<count($gaps); $i++) {
          if ($gaps[$i]['start'] <= $pairing['start'] && $gaps[$i]['end'] > $pairing['start']) {
            // Create a revised start value based on paired theme start (lead duration + lead start)
            $revised_start = ($lead['end']-$lead['start']) + $lead['start'];
            $gaps[$i]['start'] = $revised_start;
          }
          if ($gaps[$i]['start'] >= $pairing['start']) {
            if ($gaps[$i]['start']+$node->field_om_show_duration[0]['value'] <= $gaps[$i]['end'] && $gaps[$i]['start']+$node->field_om_show_duration[0]['value'] <= $pairing['end']) {
              $openings_status = 'Success';
              if ($gaps[$i]['first_airing'] == 1) {
                $scheduling_links = $scheduling_links . l('Schedule to start in paired theme ' . $pairing['title'] . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']). '/' . $channel_tid) . '<br />';
              }
              else {
                $scheduling_links = $scheduling_links . l('Schedule to start in paired theme ' . $pairing['title'] . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']). '/' . $channel_tid) . ' * <br />';
              }
            }
            else {
              // Too Long
              $openings_status = 'Too Long';
            }
          }
          else {
            // No Gaps
            $openings_status = 'No Gaps';
          }
        } // end for
      }// end if pairing
      
      
      // Write error if any, if we are on the last iteration.
      if($current_timeslot == $limit_by){
        switch($openings_status){
          case 'Success':
            $output .= $scheduling_links;
            $output .= '*first airing in timeslot';
          break;
          case "Too Long":
            if($scheduling_links){
               $output .= $scheduling_links;
               $output .= '*first airing in timeslot';
            }
            else {
              $output .= '<p>The show you are trying to schedule is larger than any available gaps in the schedule Try another timeslot.</p>';
            }
          break;
          case "No Gaps":
            $output .= '<p>There are currently no gaps in this times lot. Try again later or pick another times lot.</p>';
          break;
        }
      }
      
    } // end while timeslottheme
    
    // if there are fewer timeslots than limit send error
    if($current_timeslot < $limit_by) {
      $output .= '<p>Your show seems to have very few timeslots left. Please contact station personel to get more added.</p>';
      $output .= $scheduling_links;
    }
    
    $output .= '</div>';
    
  } // end experimentation area.om_timeslot_scheduler_find_timeslot_event_openings
  else{
    // set up non-pairings section for use with om_timeslot_scheduler_find_timeslot_event_openings()
    
    // @TODO This area is extremely experimental! Need help debugging this as it does not fit with DOM's system.
    
    if (user_access('manage scheduling') ||  user_access('administer scheduling') || $user->uid == 1) {
      $output .= '<br /> <div style="background-color:#CCCCCC; padding:3px; border: solid 1px #333333;"><h3>Scheduling</h3>';
      $output .= 'Trying to schedule ' . $node->title . '<br />';
    $output .= 'Duration: ' . $node->field_om_show_duration[0]['value'] . ' seconds<br />';
    
      //dsm($timeslot_nid);
      // @TODO: Figure out why why are passing a nid with s-... for a series?
      $timeslot_nid_cleaned = explode('-', $timeslot_nid);
      
      
      // @TODO: no idea what is going on here
      if(!$timeslot_nid_cleaned[1]) {
        $timeslot_nid_cleaned[1] = $timeslot_nid; 
      }
      
      //dsm($timeslot_nid_cleaned[1]);
      
      $result = db_query("SELECT * FROM {content_field_om_timeslot_date} otdv JOIN {term_node}  ON otdv.nid = term_node.nid JOIN {content_type_om_timeslot_event} ote ON otdv.nid = ote.nid WHERE otdv.nid = %d AND field_om_timeslot_date_value > NOW() AND ote.field_om_timeslot_userscheduled_value = 1 ORDER BY field_om_timeslot_date_value", $timeslot_nid_cleaned[1]);
      
      while ($timeslottheme = db_fetch_object($result)) {

       
        $channel_tid = $timeslottheme->tid;
        $channel = om_timeslot_scheduler_get_channel_name($timeslottheme->tid);
        
        if ($timeslottheme->field_om_timeslot_theme_nid == NULL && $is_series_nid != $timeslot_nid) {
        $gaps = om_timeslot_scheduler_find_timeslot_event_openings($timeslot_nid_cleaned[1], strtotime($timeslottheme -> field_om_timeslot_date_value), strtotime($timeslottheme -> field_om_timeslot_date_value2));
      //loop through gaps
        for ($i = 0; $i < count($gaps); $i++) {
          if ($gaps[$i]['start'] >= $timeslottheme -> field_om_timeslot_date_value) {
            if ($gaps[$i]['start']+$node->field_om_show_duration[0]['value'] <= $gaps[$i]['end']) {
              if ($gaps[$i]['first_airing'] == 1) {
                  $output = $output . l('Schedule to start ' . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']). '/' . $channel_tid) . '<br />';
              }
              else { 
                  $output .= l('Schedule to start ' . $lead['title'] . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']). '/' . $channel_tid) . ' * <br />';
              }
            }
          }
        } // end for
        $is_series_nid = $timeslot_nid;
       }
        
     $gaps = om_timeslot_scheduler_find_timeslot_event_openings($timeslot_nid, strtotime($timeslottheme -> field_om_timeslot_date_value), strtotime($timeslottheme -> field_om_timeslot_date_value2), $channel_tid);
      //loop through gaps
      for ($i = 0; $i<count($gaps); $i++) {
        if ($gaps[$i]['start'] >=  $timeslottheme -> field_om_timeslot_date_value) {
          if ($gaps[$i]['start']+$node->field_om_show_duration[0]['value'] <= $gaps[$i]['end']) {
            if ($gaps[$i]['first_airing'] == 1) {
                  
              $output .= l('Schedule to start ' . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']). '/' . $channel_tid) . '<br />';
            }
            else { 
              
              $output .= l('Schedule to start ' . $lead['title'] . date(" M j	 \a\\t	g:i a",  $gaps[$i]['start']) . ' on ' . $channel, 'om-timeslot-scheduler/self_schedule_airing/' . $node->nid . '/' . $gaps[$i]['start'] . '/' . ( $gaps[$i]['start']+$node->field_om_show_duration[0]['value']). '/' . $channel_tid) . ' * <br />';
                 
            }
          }
        }
      } // end for
      }
    }
   }
  print theme('page', $output);

}

/**
 * Helper function to allow self scheduling (om_timeslot_scheduler_find_openings) to use OPS add_airing functionality
 */
function _om_timeslot_scheduler_find_openings($nid, $start, $end, $channel_tid) {
  
  $channel_number = om_playback_servers_get_channel_number_from_tid($channel_tid);
  
  // @TODO: Why was this using custom queries vs. node_load
  
  // construct single show, show list for add_airings
  /*
$show[0] = array(
    'nid' => $nid,
    'title' => db_result(db_query('SELECT title FROM {node} WHERE nid = %d', $nid)),
    'duration' => $end - $start,
    'start' => $start,
    'end' => $end,
    'filename' => db_result(db_query('SELECT filename FROM {content_type_om_show} JOIN {files} ON field_om_show_mpeg2_fid = files.fid WHERE content_type_om_show.nid = %d', $nid)),
  );
*/

  $node = node_load($nid);
  
  $path_parts = pathinfo($node->field_om_show_mpeg2_path[0]['value']);
  
  $show[0] = array(
    'nid' => $nid,
    'title' => $node->title,
    'duration' => $end - $start,
    'start' => $start,
    'end' => $end,
    'filename' => $path_parts['basename'],
  );
  
  $output =  om_playback_servers_add_airings($channel_number, $show);
  
  _om_timeslot_scheduler_theme_self_scheduling_result($output, $start, $channel_number);
  
}

/**
 * Helper function to return themed page for user after self scheduling.
 */

function _om_timeslot_scheduler_theme_self_scheduling_result($output, $start, $channel_number) {
  drupal_set_title('Scheduling Results');
  $output .= '<p>If your file has no errors, your show has been scheduled to play at ' . date('Y-m-d H:i:s', $start) . ' on ' . $channel_number . '. Tell all your friends to tune in. </p>';
  print theme('page', $output);
}

/* om_timeslot_scheduler_find_timeslot_event_openings(int, date, date)
 * Custom function -- takes timeslot event nid start and end dates for event rang, and returns gaps in array form. aka. gap checker
 * @ $timeslot_event_nid - timeslot event nid
 * @ $date_start - date range start, default now INT
 * @ $date_end - date range end INT
 * @ $channel_tid - possible channel tid
 * @ returns array
 */


function om_timeslot_scheduler_find_timeslot_event_openings($timeslot_event_nid, $date_start = NULL, $date_end = NULL, $channel_tid = NULL) {
  
  // init array we want to populate and return.
  $gaps = array();
  // count variable for timeslot events that we will cycle through
  $event_number = 0;
  // determine date range to send if date variables are present (was using Y-m-d g:i:s) (now using Y-m-d H:i:s)
  if ($date_start) {
    $date_start = date('Y-m-d H:i:s', $date_start);
    $date_clauses .= ' AND field_om_timeslot_date_value >= "%s" ';
    }
  if ($date_end) {
    $date_end = date('Y-m-d H:i:s', $date_end);
    $date_clauses .= ' AND field_om_timeslot_date_value2 <= "%s" ';
    }
  //drupal_set_message($date_start . ' ' . $date_end);
  $result = db_query("SELECT * FROM {content_field_om_timeslot_date} otdv JOIN {term_node}  ON otdv.nid = term_node.nid JOIN {content_type_om_timeslot_event} ote ON otdv.nid = ote.nid WHERE otdv.nid = %d AND field_om_timeslot_date_value2 >= NOW()" . $date_clauses . "ORDER BY field_om_timeslot_date_value", $timeslot_event_nid, $date_start, $date_end);
  
  while ($timeslot_event = db_fetch_object($result)) {
    // daylight savings turns out not to be a problem.
    // $daylight_savings = date('I', strtotime($timeslot_event->field_om_timeslot_date_value . 'UTC')) ? 0 : 3600;
    $continued_airings_query = db_query("SELECT * FROM {content_type_om_airing} airing JOIN {term_node} tn ON airing.nid = tn.nid JOIN {node} ON  airing.nid = node.nid WHERE field_om_airing_date_value <  '%s' AND field_om_airing_date_value2 >  '%s' AND tn.tid = %d ORDER BY field_om_airing_date_value", $timeslot_event->field_om_timeslot_date_value, $timeslot_event->field_om_timeslot_date_value, $timeslot_event->tid);
    
    $continuing_airing_query = db_query("SELECT * FROM {content_type_om_airing} airing JOIN {term_node} tn ON airing.nid = tn.nid JOIN {node} ON airing.nid = node.nid WHERE field_om_airing_date_value < '%s' AND field_om_airing_date_value2 > '%s' AND tn.tid = %d ORDER BY field_om_airing_date_value", $timeslot_event->field_om_timeslot_date_value2, $timeslot_event->field_om_timeslot_date_value2, $timeslot_event->tid);
    
    $normal_airing_query = db_query("SELECT field_om_airing_date_value AS start, field_om_airing_date_value2 AS end FROM {content_type_om_airing} airing JOIN {term_node} tn ON airing.nid = tn.nid JOIN node ON airing.nid = node.nid WHERE field_om_airing_date_value >= '%s' AND field_om_airing_date_value2 <= '%s' AND tn.tid = %d ORDER BY field_om_airing_date_value", $timeslot_event->field_om_timeslot_date_value, $timeslot_event->field_om_timeslot_date_value2, $channel_tid);
    
    $get_series_query = db_query('SELECT field_om_timeslot_date_value AS start, field_om_timeslot_date_value2 AS end, node.title FROM  {content_field_om_timeslot_date} JOIN {node} ON node.nid = content_field_om_timeslot_date.nid JOIN {content_type_om_timeslot_event} ON content_type_om_timeslot_event.nid = node.nid JOIN {term_node} ON field_om_timeslot_date_value.nid = term_node.nid WHERE `field_om_timeslot_date_value` >= "%s" AND  field_om_timeslot_date_value2 <= "%s" AND field_om_project_nid IS NOT NULL AND node.nid != %d AND term_node.tid =%d', $timeslot_event->field_om_timeslot_date_value, $timeslot_event->field_om_timeslot_date_value2, $timeslot_event_nid, $channel_tid);
    
    $airingcount = 0;
    
    $previousend = strtotime($timeslot_event->field_om_timeslot_date_value . 'UTC');
    
    
    // If there is an airing starting before the beginning of the timeslot event adjust start to the end of that airing.
    while ($continued_airings = db_fetch_object($continued_airings_query)) {
          if ($continued_airings) {
            $previousend = strtotime($continued_airings->field_om_airing_date_value2 . 'UTC');
          }
    }
    
    
    // Array of mysql result resources to be looped through below. All queries must have results titled start and end. @TODO create a hook to populate the airings array.
    $resource_array = array($normal_airing_query, $get_series_query);
    
    $counter = 0;
    foreach ($resource_array as $resource) {
      
      while ($row = db_fetch_array($resource)) {
        $airings[$counter]['title'] = $row['title'];
        $airings[$counter]['start'] = strtotime($row['start'] . 'UTC');
        $airings[$counter]['end'] = strtotime($row['end'] . 'UTC');
        $airings[$counter]['duration'] = strtotime($row['end'] . 'UTC') - strtotime($row['start'] . 'UTC');
        $counter ++;
      }
    
    }
    
    usort($airings, '_om_timeslot_scheduler_sort_array');
    
    // Eventually, the below logic will be seperated out from the above airings determining logic.
    for ($a = 0; $a < count($airings); $a++) {
        //unset($mymessage);
        // airings found.
        //drupal_set_message('<pre>' . print_r($airings, true) . '</pre>');
        if ($airings[$a]['start'] - $previousend > 0) {
          //$mymessage .= '</br>not the last airing started here: ' . $airings[$a]['start'];
          //die('made it here: ' . $airingcount . '  previousend = ' . $previousend);
          $gaps[$event_number]['start'] = $previousend;
          $gaps[$event_number]['end'] = $airings[$a]['start'];
          $gaps[$event_number]['duration'] = $airings[$a]['start'] - $previousend;
          $gaps[$event_number]['first_airing'] = 1;
          $event_number ++;
          }
          $airingcount++;
          
        if ($airingcount == count($airings) && $airings[$a]['end'] < strtotime($timeslot_event->field_om_timeslot_date_value2 . 'UTC')) {
          //If we are on the last airing...
          //$mymessage .= '</br>this is the last airing: ' . $airings[$a]['start'];
          $gaps[$event_number]['start'] = $airings[$a]['end'];
          $gaps[$event_number]['end'] = strtotime($timeslot_event->field_om_timeslot_date_value2 . ' UTC');
          $gaps[$event_number]['duration'] = strtotime($timeslot_event->field_om_timeslot_date_value2 . ' UTC') - $airings[$a]['start'];
          $gaps[$event_number]['first_airing'] = 1;
          
         /*
          *  If there is an airing that starts before the end of the timeslot and goes into the next timeslot (similar to continued airings)   
          *  check to make sure we aren't encroaching upon it.
          */
            
          while ($continuing_airing = db_fetch_object($continuing_airing_query)) {
            $gaps[$event_number]['start'] = $airings[$a]['end'];
            $gaps[$event_number]['end'] = strtotime($continuing_airing->field_om_airing_date_value . ' UTC');
            $gaps[$event_number]['duration'] = $gaps[$event_number]['end']-$gaps[$event_number]['start']; // consider changing all to end - start
            $gaps[$event_number]['first_airing'] = 1;
          }
          
          $event_number++;
          }
        
        //$mymessage .= '</br>setting the previous end now : ' .  $airings[$a]['end'];
        //drupal_set_message($mymessage);
        $previousend = $airings[$a]['end'];
      }
      
      if (!$airingcount) {
        // no airings
        $gaps[$event_number]['start'] = strtotime($timeslot_event->field_om_timeslot_date_value . ' UTC');
        $gaps[$event_number]['end'] = strtotime($timeslot_event->field_om_timeslot_date_value2 . ' UTC');
        $gaps[$event_number]['duration'] = (strtotime($timeslot_event->field_om_timeslot_date_value2 . ' UTC') - strtotime($timeslot_event->field_om_timeslot_date_value . ' UTC'));
        $gaps[$event_number]['first_airing'] = 0;
        $event_number ++;
      }
      
      /* @TO DO This could probably use more logic */
      
      if ($airingcount > 0 && empty($gaps)) { 
        // no gaps
        $gaps = NULL;
      }
    }// end while timeslot_event
    
    return $gaps;
}

/**
 * usort helper function for om_timeslot_scheduler_find_timeslot_event_openings...
 */ 
function _om_timeslot_scheduler_sort_array($a, $b) {
  return ($a['start'] < $b['start']) ? -1 : 1;
}


/**
 * Checks the permissions for the Scheduling tab
 */
function om_timeslot_airing_options_access($node) {

  if ($node->type == 'om_show') {
    global $user;

    //check if project administrators are allowed to schedule first airings
    if (variable_get('om_timeslot_scheduler_admin_scheduled_first_airing', '')) {
      $groupnode = og_get_group_context();
      
      //og_get_group_context is not returning the group node properly in some cases
      //so we do a manual check if it is empty
      if (!$groupnode) {
        $project_owner = db_fetch_array(db_query('SELECT uid FROM {og_ancestry} LEFT JOIN {og_uid} ON og_ancestry.group_nid = og_uid.nid WHERE og_ancestry.nid = %d AND og_uid.is_admin = 1', arg(1)));
  if (in_array($user->uid, $project_owner)) {
          return TRUE;
        }
      }
      else{
        if (og_is_group_admin($groupnode)) {
          return TRUE;
        }
      }
    }

     if ( $user->uid == $node->uid && user_access('access scheduling options of own shows') || user_access('access scheduling options of all shows') || user_access('manage scheduling') ||  user_access('administer scheduling') || user_access('administer Open Media System')) {
       return TRUE;
     } 
     else {    
        return FALSE;
     }  
  } 
  else {
     return FALSE;
  } // if node == om_show
}

/**
 * Simple function that returns human readable title
 */
function om_timeslot_scheduler_title_from_nid($nid) {
  
  $result = db_query("SELECT title FROM {node} n WHERE nid = %d", $nid);

  $om_theme = db_fetch_object($result);

  return $om_theme->title;

}

/**
 * Returns all the channels as an array starting with None
 */
function om_timeslot_scheduler_get_channels() {
  $terms = taxonomy_get_tree(variable_get('om_timeslot_channel_vocabulary', 0));

  $channel[0] = 'None';
    foreach ( $terms as $term ) {
      $channel[$term->tid] = $term->name;
    } 
      
  return $channel;
}

/**
 *  Return server node given channel tid and type.
 */
function om_timeslot_scheduler_get_servers($channel_tid, $server_type = NULL) {
  if($server_type) {
    $where = " AND field_om_timeslot_server_type_value = '".$server_type."'";
  }

  if ($channel_tid == 'all') {
    //return all servers
    $result = db_query("SELECT * FROM {term_node} tn JOIN {node} n ON tn.vid = n.vid JOIN {content_type_om_timeslot_server} ON content_type_om_timeslot_server.vid = n.vid WHERE type = '%s'", 'om_timeslot_server');

} 
  else {
    $result = db_query("SELECT * FROM {term_node} tn JOIN {node} n ON tn.vid = n.vid JOIN {content_type_om_timeslot_server} ON content_type_om_timeslot_server.vid = n.vid WHERE tid = %d and type = '%s'".$where, $channel_tid, 'om_timeslot_server');
  }
  //$stuff = db_fetch_object($result);
  return db_fetch_object($result);

}

/**
 * Simple function to return the human readable channel name from the term id
 */
function om_timeslot_scheduler_get_channel_name($channel_tid) {
  
  $channel = taxonomy_get_term($channel_tid);
    
  return $channel->name;

}

/**
 * Formats calendar items to include pairing information.
 * 
 * #LK This area is under construction.
 * 
 * This function takes om_timeslot_event nodes, and returns scheduling links for om_timeslot_themes
 * that fall within each event.
 * 
 * @param $nid
 *  An integer containing the node id of an om_timeslot_event node
 * @param $orgstart
 *  A unix timestamp representing the start date/time of the om_timeslot_event node
 *  This is NOT the same as the date/time available from the event node itself. For more details
 *  please see the comments at the beginning of calendar-month-node.tpl.php #LK NO DATE DATA IS BEING SENT FROM THIS TEMPLATE FOR   
 *  START OR END.
 * @param $orgend
 *  A unix timestamp representing the end date/time of the om_timeslot_event node
 *  Same situation as $Same situation as $orgstart -- not the same as end date on node. See calendar template
 *  file comments for more details
**/
 
function om_timeslot_scheduler_format_calendar_display($nid, $orgstart = NULL, $orgend = NULL, $channel_tid) {
  
  // WHAT IF THIS IS NOT A PAIRINGS BASED SYSTEM? 
  /** 
   * #LK 
   * We can't just load the node this will send many date values to om_timeslot_pairings_calculate_pair_times which will generate 
   *  bad data
   * $node = node_load($nid);
   */
   
  // If either date value is null this will cause massive problems, so we end.
  if($orgstart == NULL || $orgend == NULL){
    return $output .= 'Incompatible or NULL date information was sent from the timeslot calendar view.';
  }
  
  $modified_orgstart =  gmstrftime("%Y-%m-%d-%H:%M:%S", $orgstart);
  $modified_orgend =  gmstrftime("%Y-%m-%d-%H:%M:%S", $orgend);
  
  $node_object_query = db_query('SELECT * FROM {content_field_om_timeslot_date} AS cfotd JOIN  {content_type_om_timeslot_event} AS ctote ON ctote.nid = cfotd.nid JOIN {content_field_om_timeslot_rule} AS cfotr ON cfotd.nid = cfotr.nid WHERE field_om_timeslot_date_value <= "%s" AND field_om_timeslot_date_value2 >= "%s" AND cfotd.nid = %d', $modified_orgstart, $modified_orgend, $nid);
  
  $node_object = db_fetch_object($node_object_query);
    
  /**
   * #LK 12/13/10 probably need to look into updating this function soon. Don't think we need to do any of this pairing 
   * calculation here, because pairings are handled by scheduling in bulk scheduling, and theme markup is handled in tv    
   * frame at the moment. But maybe this should be considered in a larger scale conversation about interface and tv frame.
   * The following is temporary, and creates a redundancy.
   */
   
  $start = strtotime($node_object -> field_om_timeslot_date_value . 'UTC');
  $end = strtotime($node_object -> field_om_timeslot_date_value2 . 'UTC');
  
  $node_object -> field_om_timeslot_date[0][value] = $node_object -> field_om_timeslot_date_value;
  $node_object -> field_om_timeslot_date[0][value2] = $node_object -> field_om_timeslot_date_value2;
  $lead_nid = $node_object->field_om_timeslot_theme_nid;
  $pairing_nid = db_result(db_query("SELECT pairing_nid FROM {om_timeslot_pairings} WHERE theme_nid = %d", $lead_nid));
  
  $theme_pair -> field_om_timeslot_lead_last_value = $node_object -> field_om_timeslot_lead_last_value;
  $theme_pair -> pairing_nid = $pairing_nid;
  $theme_pair -> theme_nid = $lead_nid;
  
  //$paired_theme = om_timeslot_pairings_pairing_info_from_event_nid($nid);
  
  if ($pairing_nid) {
    //grab the pairing information, start time / end time for lead and pair.
    $pair_info = om_timeslot_pairings_calculate_pair_times($node_object, $theme_pair);
    $lead_title = om_timeslot_scheduler_title_from_nid($pair_info['leadnid']);
    $paired_title = om_timeslot_scheduler_title_from_nid($pair_info['pairnid']);
    $lead_timeslot_theme = str_replace(array('&', ',', ' ', '/'), array('', '', '-', ''), strtolower($lead_title));
    $pair_timeslot_theme = str_replace(array('&', ',', ' ', '/'), array('', '', '-', ''), strtolower($paired_title));
    if ($node_object->field_om_timeslot_date_rrule) {
      if (user_access('manage scheduling') ||  user_access('administer scheduling') || user_access('administer Open Media System') ) {
        //$channel = reset($node->taxonomy);
        //NOTE: this attempts to use orgstart & orgend, probably needs updated
        
        // expected fromat start/end/channel_tid/commit/rules/inc_lead/inc_pair
        
        $autoscheduleleadlink = ' - ' . l('schedule', 'admin/openmedia/review/bulkschedule/' . $start . '/' . $end . '/' . $channel_tid . '/0/' . $node_object->field_om_timeslot_rule_nid . '/' . '1/0');
        $autoschedulepairlink = ' - ' . l('schedule', 'admin/openmedia/review/bulkschedule/' . $start . '/' . $end . '/' . $channel_tid . '/0/' . $node_object->field_om_timeslot_rule_nid . '/' . '0/1');
        
       }
        $output .= '<div class="theme-' . $lead_timeslot_theme . '"><div>'. $lead_title . ' starts at ' . date('g:i:s a', $pair_info['leadstart']) . $autoscheduleleadlink . '</div></div>';
        $output .= '<div class="theme-' . $pair_timeslot_theme . '"><div>'. $paired_title . ' starts at ' . date('g:i:s a', $pair_info['pairstart']) . $autoschedulepairlink . '</div></div>';
      }
   } 
   else {
     if (user_access('manage scheduling') ||  user_access('administer scheduling') || user_access('administer Open Media System')) {
       if (($node_object -> field_om_timeslot_date_rrule && $node_object->field_om_timeslot_rule_nid)) {
          //NOTE: this attempts to use orgstart & orgend, probably needs updated
         $output = $output . l('schedule', 'admin/openmedia/review/bulkschedule/' . $start . '/' . $end . '/' . $channel_tid . '/0/' . $node_object->field_om_timeslot_rule_nid . '/' . '1/1');
         }
       }
     }
  return $output;
}

/**
 * Checks the permissions for the Scheduling tab
 */
function om_timeslot_playback_server_status_access($node) {
  
  
  if ($node->type == 'om_timeslot_server') {
    global $user;
    
    if ( user_access('administer scheduling') || user_access('administer Open Media System')) {
       return TRUE;
    } 
    else {    
        return FALSE;
     }  
  } 
  else {
     return FALSE;
  } // if node == om_timeslot_server
}

function om_timeslot_playback_server_status($node) {
  
  $output .= l('Remount' . $node->field_om_timeslot_server_mount[0]['value'], '/admin/openmedia/om-timeslot-scheduler/remount/' . $node->nid);
  
  $output .= om_timeslot_princeton_list_failed_files($node->field_om_timeslot_server_mount[0]['value']);
  
  print theme('page', $output);
}

function om_timeslot_playback_server_remount($node) {
  //print_r($node);
  print 'mount ' . $node->field_om_timeslot_server_mount[0]['value'] . '<br />';
  print exec('mount ' . $node->field_om_timeslot_server_mount[0]['value']);
}


function om_timeslot_scheduler_manage() {

  $output .= om_timeslot_server_status();
  
  $output .= '<div id="om_timeslot_rules">';
  $output .= '<h2>Timeslot Rules</h2>';
  $view = views_get_view('om_timeslot_rules', 'default');
  $view->override_path = $_GET['q'];
  $output .= $view->preview();
  $output .= '</div>';
  
  $output .= '<div id="om_timeslot_themes">';
  $output .= '<h2>Timeslot Themes</h2>';
  //$output .= views_embed_view('om_timeslot_themes','default');
  //$view = views_get_view('om_timeslot_rules','default');
  //$output .= views_build_view('embed', $view);
  
  $view = views_get_view('om_timeslot_themes');
  if (!empty($view)) {
    $output .= $view->execute_display('default', $view_args);
  }
  $output .= '</div>';
  
  
  print theme('page', $output);
  
}

function om_timeslot_scheduler_manage_events() {
 
  //$view = views_get_view('timeslot_calendar','Calendar page');
  //$view->override_path = implode("/", arg());
  //$output = $view->preview();
  
  //print theme('page', $output);
  
  //This View still requires a preprocess function in template.php.  Does not work in Garland.
  header('Location: ' . '/timeslot-calendar/');
}
/* #LK Does this view even still exist? What is $view->preview() method supposed to do? Why not just print
 * the views object content. The error this causes is some how associated with try to initialize the view handler as a
 * std. obj. I think $view->preview() is not neccesary.
 */
function om_timeslot_scheduler_manage_themes() {
  $view = views_get_view('timeslot_themes', 'default');
  $view->override_path = $_GET['q'];
  $output = $view->preview();

  print theme('page', $output);
}


/**
 * Implementation of hook_nodeapi
 *
 */
/*
function om_timeslot_scheduler_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case 'view':
      if($node->type == 'om_timeslot_theme') {
       print views_embed_view('om_timeslot_events_for_theme', 'default', $node->nid);
       
       $sql = "SELECT node.nid AS nid,
       node.vid AS node_vid,
       node.title AS node_title,
       node.type AS node_type
       FROM node node 
       LEFT JOIN content_field_om_timeslot_date node_data_field_om_timeslot_date ON node.vid = node_data_field_om_timeslot_date.vid
       LEFT JOIN content_type_om_timeslot_event node_data_field_om_timeslot_theme ON node.vid = node_data_field_om_timeslot_theme.vid
       WHERE ((node.type in ('om_timeslot_event')) AND (node_data_field_om_timeslot_theme.field_om_timeslot_theme_nid = 2128))
    AND (DATE_FORMAT(node_data_field_om_timeslot_date.field_om_timeslot_date_value, '%Y-%m-%d') >= '2010-04-21')";

      }
      if($node->type == 'om_timeslot_event') {
       
       if($node->field_om_timeslot_theme[0]['nid']){
         $title = $node->title . om_timeslot_pairings_pairing_titles($node->field_om_timeslot_theme[0]['nid']);
       } else {
         
         $project = node_load($node->field_om_project[0]['nid']);
         $title = $node->title . ' - ' . $project->title;
       }
       
       drupal_set_title(check_plain($title));
      }
      break;
  }
}
*/

function om_timeslot_server_status() {
  
   $result = db_query("SELECT * FROM {node} JOIN {content_type_om_timeslot_server} ON node.vid = content_type_om_timeslot_server.vid WHERE type = '%s'", 'om_timeslot_server');
    
    
    while ($server = db_fetch_object($result)) {
       
       if (variable_get('om_timeslot_server_' . $server->nid . '_status', '0')) {
         $status = '<b style="color:green">ONLINE</b>';
       } 
       else {
         $status = '<b style="color:red">OFFLINE: Media Disk Status Above 90%</b>';
       }
       
       if ($server->field_om_timeslot_server_type_value == 'princeton' && om_timeslot_princeton_check_mount($server->field_om_timeslot_server_mount_value)) {
          $status .= ' | <b style="color:green">MOUNTED</b>';
       } 
       else {
          $status .= ' | <b style="color:red">NOT MOUNTED</b>';
       }
       $output .= l($server->title, 'node/' . $server->nid . '/playback-status') . ' - ' . $status . '<br />';
    }
    
    return $output;
}

/**
 * om_timeslot_purge_temp_airings($start, $end)
 * Delete all temp airings where title contains temp pattern 'temp -' within a certain date range. Typically
 * this should be called everytime the update function is called to prevent build up of large amounts of temp
 * airing nodes.
 * WARNING this function progrmatically DELETES AIRINGS BE CAREFUL. 
 * @param $start date string YYYY-MM-DD HH:MM:SS
 * @param $end same as start
 */

function om_timeslot_purge_temp_airings($start, $end, $channel_tid) {
  if(is_numeric($start) || is_numeric($end)) {
    // improperly formatted dates could delete all airings. We want to kill the script if that happens.
    // consider if $start is malformed dec 1st 1969, and end is ok. no more airings.
    age('Warning: om_timeslot_purge_temp_airings date format is incorrect.', 'warning');
    return;
  }
  $find_temps_to_delete = db_query('SELECT * FROM {node} JOIN {content_type_om_airing} ctoa ON node.nid = ctoa.nid JOIN {term_node} ON ctoa.nid = term_node.nid WHERE title LIKE "%temp - %" AND type = "om_airing" AND field_om_airing_date_value >= "%s" AND field_om_airing_date_value2 <= "%s" AND term_node.tid = %d', $start, $end, $channel_tid);
    
  while ( $temps_to_delete_obj = db_fetch_object($find_temps_to_delete)) {
    watchdog('om_timeslot_scheduler::purge_temp_airings', 'Deleting: ' . $temps_to_delete_obj->nid, WATCHDOG_WARNING);
    node_delete($temps_to_delete_obj->nid);
  }
}

/**
 * This function will return a vocabulary object which matches the
 * given name. Will return null if no such vocabulary exists.
 *
 * @param String $vocabulary_name
 *   This is the name of the section which is required
 * @return Object
 *   This is the vocabulary object with the name
 *   or null if no such vocabulary exists
 */
function om_timeslot_scheduler_get_vocabulary_by_name($vocabulary_name) {
  $vocabs = taxonomy_get_vocabularies(NULL);
  foreach ($vocabs as $vocab_object) {
    if ($vocab_object->name == $vocabulary_name) {
      return $vocab_object;
    }
  }
  return NULL;
}
